import lingo/pegcode/driver;
Expr ::= Int, Sub, Add, Mult, Div;
Int(value : int);
Sub(l : Expr, r : Expr);
Add(l : Expr, r : Expr);
Mult(l : Expr, r : Expr);
Div(l : Expr, r : Expr);

// Singleton keeping the compiled grammar

lingoGrammarOp : ref Maybe<[PegOp]> = ref None();
lingoGrammar() {
    // Prepare the grammar in the given file using flow syntax for inlining a string from a file
    // but be sure to only do this once
    onlyOnce(lingoGrammarOp, \ -> {
    compilePegGrammar("#include lingo.lingo");
    });
}

astToString(expr : Expr) -> string{
    switch(expr){
        Sub(l, r) :  "Sub("  + astToString(l) + ", " + astToString(r) + ")";
        Div(l, r) :  "Div("  + astToString(l) + ", " + astToString(r) + ")";
        Mult(l, r) : "Mult(" + astToString(l) + ", " + astToString(r) + ")";
        Add(l, r) :  "Add("  + astToString(l) + ", " + astToString(r) + ")";
        Int(v) :     "Int("  + i2s(v) + ")";
    }
}

/*calculate(expr : Expr) -> Maybe<double>{
    switch (expr) {
        Sub(l, r) : calculate(l) / calculate(r);
        Div(l, r) : {if(l==None()||r==None()||l==r){None();} else{Some(calculate(l) / calculate(r))}}
        Mult(l, r) : calculate(l) * calculate(r);
        Add(l, r) : calculate(l) + calculate(r);
        Int(v) : i2d(v);
    }
}*/

main() {
    // Here we parse a string against the grammar
    result = parsic(lingoGrammar(), "(((1-2)*3)/(3+3))", defaultPegActions);
   /* if(None()==None()){
        println("yes");
    }*/
    
    println("AST: " + result);
    println("AST to string: " + astToString(result));
   // println("Calculated result:" + calculate(result));
}